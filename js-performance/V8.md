涉及内容

- V8 引擎执行流程
- 代码优化实例

# V8 引擎执行流程

浏览器中存在渲染引擎，V8 是专门用来处理 js 代码的，代码执行之前是会经历一个大编译过程，而作用域和作用链在这个编译阶段就已经确定了，之后再进行词法分析、语法分析、预解析、全量解析、编译、执行、最后在堆栈层面上进行一些分析。

![](../image/js-performance-11.png)

## scanner

scanner 是一个扫描器，对纯文本的 javascript 代码进行词法分析，把代码分析成不同的 tokens
比如定义了一个 username 变量，scanner 对其扫描之后会得到相应的 token 集合

```javascript
const username = "alishi";

// scanner对此行代码扫描之后会得到：
[
  {
    type: "Keyword",
    value: "const",
  },
  {
    type: "Identifier",
    value: "username",
  },
  {
    type: "Punctuator",
    value: "=",
  },
  {
    type: "String",
    value: "alishi",
  },
];
```

## Parser

Parser 是一个解析器，解析的过程其实是一个语法分析的过程，会把词法分析结果的 tokens 转换成抽象的语法树，并在语法分析的过程做语法校验，如果有错误则抛出错误。

![](../image/js-performance-12.png)

Parser 的解析有两种情况：预解析与全量解析。在一般代码中会存在很多声明，但后续不被使用的情况，此时如果直接做全量解析太过浪费。

### 预解析优点

- 跳过未被使用的代码
- 不生成 AST，创建无变量引用和声明的 scopes
- 依据规范抛出特定错误
- 解析速度更快

```javascript
// 声明了两个函数，但是func1未被使用到，因此对于func1的解析过程就是预解析，但仍然会生成作用域的信息
function func1() {
  console.log("func1");
}
function func2() {
  console.log("func2");
}
func2();
```

### 全量解析

- 解析被使用的代码
- 生成 AST
- 构建具体 scopes 信息，变量引用、声明等
- 抛出所有语法错误

```javascript
// 声明时未调用，因此会被认为是不被执行的代码，进行预解析
function foo() {
  consol.log("foo");
}
// 声明时未调用，因此会被认为是不被执行的代码，进行预解析
function fn() {}

// 函数立即执行，只进行一次全量解析
(function bar() {})();

// 执行foo，那么需要重新对foo函数进行全量解析，此时foo函数被解析了两次
foo();
```

## Lgnition

Lgnition 是 V8 提供的一个解释器，也可以看作是一个预编译的过程，基于性能的考虑，预编译与编译无太大区分，因为有些代码在预编译阶段就可以直接执行。

## TurboFan

TurboFan 是 V8 提供的编译器模块

## 堆栈操作

关键词：ECStack-执行环境栈、执行上下文、VO(G)-全局变量对象、GO-全局对象

js 代码执行需要一个环境，所以在浏览器中有 js 执行引擎（比如 V8），代码最终会被转为可识别的机器码，这些字符串形式的机器码在哪执行呢？这个就轮到“执行环境栈（ECStack, execution context stack）”出场了，浏览器在渲染界面时，会在计算机的内存中开辟一片内存空间（称为执行环境栈），用来执行 js 代码，而栈内存就是执行环境栈，而不同的代码需要进行隔离，比如有两个函数，同名，但是分别位于全局和局部，如何区分代码执行呢？此时就需要提到“执行上下文”了，全局的上下文用于管理全局代码的执行，某一个私有的上下文就管理这个局部的代码执行。当前执行上下文执行完毕之后，会有一个出栈的操作，出栈之后，所存储的变量以及值会被释放，而所引用的对象是否会被释放取决于垃圾回收机制。

在全局的执行上下文中，可能同时会存在很多个变量声明，而这些变量声明都存放在全局变量对象-VO(G)所占据的空间里。

```javascript
var x = 100;
// 假设不考虑变量提升，即代码是直接执行的，那么此行代码的执行会有以下步骤：
// 1.创建一个值100，由于100是一个基本数据类型值，所以会直接存放在栈区
// 2.声明一个变量，存放在VO(g)中
// 3.建立变量与值之间的联系
```

- 基本数据类型是按值进行操作，基本数据类型值是存放在栈区的，无论是栈内存，还是后续引用数据类型会使用的堆内存，都属于计算机内存
- GO：全局对象，它并不是 VO(G)，但也是一个对象，因此它也会有一个内存的空间地址（有地址就可以对其进行访问，js 会在 VO(g)中准备一个变量 window，用于访问 GO 对象中的属性）。浏览器在渲染界面时，会在计算机的内存中申请多个内存空间，其中一个空间是用来管理 GO 的。GO 中存放了 JS 可以直接调用的 API，比如 setTimeout、setInterval，可以通过“window.\*\*”方式调用的 API 都存放在 GO 中

## 引用类型堆栈处理

```javascript
var a = b = 1;
// 这行代码其实执行的顺序是：
// var a = 1
// a = b 或 b = 1

var obj1.y = obj1 = { x: 200 };
// 由于运算符优先级问题，此行代码与var obj1 = obj1.y = { x: 200 } 等价，先执行obj1.y
// var obj1.y = { x: 200 };  创建了2个内存空间0x00与0x01，0x00中存放了y:0x001 ,0x001中存放了x:200；VO(G)中的obj1指向了0x000
// obj1 = { x: 200 };        VO(G)中的obj1指向了0x001
```

```javascript
var obj1 = { x: 100 }; // 此行代码执行了两个事：1.申请了一个内存空间0x000，存放了x:100 2.VO(G)中的obj1指向了0x000

var obj2 = obj1; // 2.VO(G)中的obj2指向了0x000

obj1.y = obj1 = { x: 200 };
// 1.obj1.y={ x: 200 }， 申请了一个内存空间0x001，存放了x:200；内存空间0x000中存放了x:100与y：0x001
// 2.obj1 = { x: 200 }，VO(G)中的obj1指向了0x001，内存空间0x000中存放了 x:100与y：0x001 变成了 x:100与y：0x000

console.log(obj1.y); // 输出undefined，因为上一步骤使得obj1指向了0x001，其中只有x:200
console.log(obj2); // 输出一个对象：{x: 100, y:{x:200}}
```

![](../image/js-performance-13.png)

## 函数堆栈处理

- 变量提升阶段：创建函数和创建变量类似，函数名此时就可以看作是一个变量
